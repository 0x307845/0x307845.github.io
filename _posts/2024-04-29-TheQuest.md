---
title: TheQuest
date: 2024-04-29 00:44:00+0100
categories: ['InsomniHack', '2024']
tags: [ctf] # TAG names should always be lowercase
math: true
mermaid: true
---

During the Insomni'hack 2024 CTF, A colleague and I did this challenge, we decided to make a writeup for it because the methods used to solve this challenge were really interesting to explain. 
The goal of this challenge is to open every part of the wooden box next to admin tables.

{Photo}
### Initial Step : Read the introduction

Here's the map provided in the challenge statement. It represents the room where the CTF takes place. You can see three red circles, each representing the starting point of the three parts necessary to solve the box. Each part can be solved independently of the others.

![](/src/img/TheQuest/TheQuest1.png)

### First Step : Painful Bruteforce

When you arrive at location number 1, you'll find a table. On it, there's a bowl containing convention badges and 2 books. After flipping through the books, you'll find a USB key containing an interesting file `firmware_keypad.bin`. We decided to reverse the code with BinaryNinja and we find a function called `validate_code`.

```c
uint64_t validate_code()

      int64_t var_38
      __builtin_strcpy(dest: &var_38, src: ":1N50QU357")
      int64_t var_8 = 0x19
      void var_140
      void* var_10 = &var_140
      strcpy(var_10, &code, 0x33555130354e313a)
      strcat(var_10, &var_38)
      size_t var_18 = 0x10
      int64_t var_20 = 0xf
      md5String(var_10, &var_140 - 0x10)
      int128_t var_a0
      __builtin_strncpy(dest: &var_a0, src: "33c12ea236cc81d7deb97e432aedc9d4", n: 0x21)
      void* x0_6
      int64_t x1_2
      x0_6, x1_2 = hexstr_to_char(&var_a0)
      void var_78
      fastpbkdf2_hmac_sha512(&var_140 - 0x10, var_18, x0_6, x1_2, 0x64, &var_78, 0x40)
      void* x0_9
      int64_t x1_5
      x0_9, x1_5 = hexstr_to_char("6d47dd806bdf0677abfdca674206650a…")
      if (x1_5 == 0x40)
          int32_t x0_12 = memcmp(&var_78, x0_9, 0x40)
          free(x0_9)
          int64_t var_c0_1 = 0
          free(x0_6)
          int64_t var_b0_1 = 0
          return zx.q(x0_12)
      __assert_fail(assertion: "expected.length == PKBDF2_OUT_SI…", file: "firmware.c", line: 0x8d, function: "validate_code")
      noreturn
```

In this function, the "fastpbkdf2_hmac_sha512" function is used to create the character string used for authentication: `6d47dd806bdf0677abfdca674206650aaa58fcb3669e76d1b60fb1fb91d50a54f4483f6a721cc3e8acc87f536f9419d782dcc8e7b443574530`

The objective here is to create a Python script that follows the same process of generating this character string in order to brute force the code of the keypad.

So, in the code, we identify the different steps used to generate the string:
1. Concatenation of the code entered on the keypad with the string `:1N50QU357`.
2. Hashing of the newly created string using MD5.
3. Utilization of the pbkdf2_hmac algorithm with the following parameters found in the call of the function :
   - Length: `64`
   - Salt: `0x33c12ea236cc81d7deb97e432aedc9d4`
   - Iterations: `100`
   - Algorithm: `SHA-512`

We learned from the challenge admin that the code was at least ten characters long. In the code, the variable `code` used has a buffer of 20 characters, so we know that the code is between 10 and 20 characters long. On the keypad, there are 14 possible characters, making brute-forcing a password impossible within the competition time frame. This leads us to believe that we are missing an element to reduce the number of possibilities.

Let's recall that on table number 1, in addition to the USB key, there were badges. The idea here is to go to the wooden box and lift the locker with badges under the keypad to find inside a blacklight lamp. Once passed over the keypad, we can see the characters used in the code.

![](/src/img/TheQuest/TheQuest2.png)

So, we see that the characters used are `14b#`. The character `* `was not counted as it was used to validate the code. Consequently, this greatly reduces the number of possibilities. Unfortunately, we do not know the exact length of the password, so all we can do is wait for our code to find the correct one.

```python
import itertools
import binascii
import hashlib
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend

def generate_hash(code):
    # Concatenate the special string
    full_code = code + ":1N50QU357"
    
    # Hash the complete code string using MD5
    md5_hasher = hashlib.md5()
    md5_hasher.update(full_code.encode())
    code_hash = md5_hasher.digest()

    # Fixed salt
    salt = binascii.unhexlify("33c12ea236cc81d7deb97e432aedc9d4")

    # Create a PBKDF2HMAC object
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA512(),
        length=64,  # The output size in bytes
        salt=salt,
        iterations=100,
        backend=default_backend()
    )

    # Generate and return the PBKDF2 hash
    return kdf.derive(code_hash)

# Expected hash prefix for comparison
expected_prefix = "6d47dd806bdf0677abfdca6"

# Initialize counter for controlling the printing frequency
print_counter = 0

# Bruteforce loop
for i in range(4, 19):  # Loop from length 4 to 18
    characters = '14B#'
    n = i  # Number of positions

    # Generating all possible combinations of length n
    for combination in itertools.product(characters, repeat=n):
        print_counter += 1
        trying = ''.join(combination)
        current_hash = generate_hash(trying)
        current_hex = binascii.hexlify(current_hash).decode()

        # Print only every 10,000 tests or if the correct hash is found
        if print_counter % 10000 == 0 or current_hex.startswith(expected_prefix):
            print(f"Testing {print_counter}: Trying: {trying}, Generated Hash: {current_hex}")

        if current_hex.startswith(expected_prefix):
            print("Found it! Matching prefix:", expected_prefix)
            break
    if current_hex.startswith(expected_prefix):
        break
```

We finally find it after 30 minutes ... (plz next time give the exact lenght with the lamp) 

![](/src/img/TheQuest/TheQuest3.png)

We enter the code and obtain the first part of the flag : `1-5054fd46a2cfcf70a598c2faded5cb`

### Second Part : Don't use Popen


